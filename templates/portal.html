<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kalshi Trading Portal</title>
<style>
  :root {
    --bg: #0a0e14;
    --card: #111820;
    --card-border: #1e2a3a;
    --text: #e2e8f0;
    --text-dim: #8899aa;
    --accent: #3b82f6;
    --green: #22c55e;
    --red: #ef4444;
    --orange: #f59e0b;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'SF Mono', 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Header */
  .header {
    display: flex;
    align-items: center;
    padding: 0 1rem;
    height: 48px;
    background: var(--card);
    border-bottom: 1px solid var(--card-border);
    flex-shrink: 0;
  }
  .header h1 {
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.5px;
    margin-right: 2rem;
    white-space: nowrap;
  }

  /* Tab bar */
  .tabs {
    display: flex;
    gap: 2px;
    overflow-x: auto;
  }
  .tab {
    padding: 0.6rem 1.2rem;
    cursor: pointer;
    font-size: 0.8rem;
    font-family: inherit;
    border: none;
    background: transparent;
    color: var(--text-dim);
    border-bottom: 2px solid transparent;
    transition: all 0.15s;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .tab:hover { color: var(--text); background: rgba(255,255,255,0.03); }
  .tab.active {
    color: var(--text);
    border-bottom-color: var(--accent);
    background: rgba(59,130,246,0.08);
  }
  .tab .dot {
    width: 8px; height: 8px; border-radius: 50%;
    display: inline-block;
    background: var(--text-dim);
  }
  .tab .dot.healthy { background: var(--green); }
  .tab .dot.unhealthy { background: var(--red); }

  /* Panels */
  .panel-container {
    flex: 1;
    position: relative;
    overflow: hidden;
  }
  .panel {
    position: absolute;
    inset: 0;
    display: none;
  }
  .panel.active { display: flex; flex-direction: column; }

  /* Overview panel */
  .overview {
    padding: 1.5rem;
    overflow-y: auto;
  }
  .overview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
  }
  .overview-header h2 { font-size: 1.1rem; font-weight: 600; }
  .total-pnl {
    font-size: 1.5rem;
    font-weight: 700;
  }
  .total-pnl.positive { color: var(--green); }
  .total-pnl.negative { color: var(--red); }
  .total-pnl.zero { color: var(--text-dim); }

  .bot-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 1rem;
  }
  .bot-card {
    background: var(--card);
    border: 1px solid var(--card-border);
    border-radius: 8px;
    padding: 1.25rem;
    border-left: 3px solid var(--text-dim);
    transition: border-color 0.2s;
  }
  .bot-card:hover { border-color: var(--accent); }
  .bot-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }
  .bot-card-title {
    font-size: 0.95rem;
    font-weight: 600;
  }
  .bot-badge {
    font-size: 0.7rem;
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: 600;
  }
  .bot-badge.healthy { background: rgba(34,197,94,0.15); color: var(--green); }
  .bot-badge.unhealthy { background: rgba(239,68,68,0.15); color: var(--red); }
  .bot-badge.unknown { background: rgba(136,153,170,0.15); color: var(--text-dim); }

  .bot-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
  }
  .stat-item { }
  .stat-label {
    font-size: 0.7rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
  }
  .stat-value {
    font-size: 1rem;
    font-weight: 600;
  }
  .stat-value.positive { color: var(--green); }
  .stat-value.negative { color: var(--red); }

  .bot-card .error-msg {
    color: var(--red);
    font-size: 0.8rem;
    opacity: 0.8;
  }

  .bot-card .open-btn {
    display: inline-block;
    margin-top: 1rem;
    font-size: 0.75rem;
    color: var(--accent);
    cursor: pointer;
    border: none;
    background: none;
    font-family: inherit;
    padding: 0;
  }
  .bot-card .open-btn:hover { text-decoration: underline; }

  /* Refresh indicator */
  .refresh-info {
    font-size: 0.7rem;
    color: var(--text-dim);
  }

  /* Iframe panels */
  .panel iframe {
    width: 100%;
    height: 100%;
    border: none;
  }
  .iframe-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--text-dim);
    font-size: 0.9rem;
  }

  /* Capital panel */
  .capital { padding: 1.5rem; overflow-y: auto; }
  .capital-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 1.5rem;
  }
  .capital-header h2 { font-size: 1.1rem; font-weight: 600; }
  .capital-total {
    font-size: 1.5rem; font-weight: 700;
  }

  .sub-cards {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
    gap: 1rem; margin-bottom: 2rem;
  }
  .sub-card {
    background: var(--card); border: 1px solid var(--card-border);
    border-radius: 8px; padding: 1.25rem; border-left: 3px solid var(--text-dim);
  }
  .sub-card-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 0.75rem;
  }
  .sub-card-label { font-size: 0.95rem; font-weight: 600; }
  .sub-card-badge {
    font-size: 0.65rem; padding: 2px 6px; border-radius: 4px;
    background: rgba(59,130,246,0.15); color: var(--accent); font-weight: 600;
  }
  .sub-card-balance {
    font-size: 1.4rem; font-weight: 700; margin-bottom: 0.5rem;
  }
  .sub-card-bot {
    font-size: 0.75rem; color: var(--text-dim);
  }

  .capital-section {
    background: var(--card); border: 1px solid var(--card-border);
    border-radius: 8px; padding: 1.25rem; margin-bottom: 1.5rem;
  }
  .capital-section h3 {
    font-size: 0.9rem; font-weight: 600; margin-bottom: 1rem;
    color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px;
  }
  .form-row {
    display: flex; gap: 0.75rem; align-items: flex-end; flex-wrap: wrap;
  }
  .form-group { display: flex; flex-direction: column; gap: 4px; }
  .form-group label {
    font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase;
  }
  .form-group select, .form-group input {
    background: var(--bg); border: 1px solid var(--card-border); color: var(--text);
    padding: 0.5rem 0.75rem; border-radius: 4px; font-family: inherit; font-size: 0.85rem;
    min-width: 140px;
  }
  .btn {
    padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer;
    font-family: inherit; font-size: 0.8rem; font-weight: 600;
    transition: opacity 0.15s;
  }
  .btn:hover { opacity: 0.85; }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-primary { background: var(--accent); color: #fff; }
  .btn-green { background: var(--green); color: #fff; }
  .btn-red { background: var(--red); color: #fff; }
  .btn-small { padding: 0.3rem 0.6rem; font-size: 0.7rem; }

  .feedback {
    margin-top: 0.75rem; font-size: 0.8rem; min-height: 1.2em;
  }
  .feedback.ok { color: var(--green); }
  .feedback.err { color: var(--red); }

  .mgmt-table {
    width: 100%; font-size: 0.8rem; border-collapse: collapse;
  }
  .mgmt-table th, .mgmt-table td {
    padding: 0.5rem 0.75rem; text-align: left;
    border-bottom: 1px solid var(--card-border);
  }
  .mgmt-table th { color: var(--text-dim); font-weight: 600; text-transform: uppercase; font-size: 0.7rem; }
  .mgmt-table input, .mgmt-table select {
    background: var(--bg); border: 1px solid var(--card-border); color: var(--text);
    padding: 0.3rem 0.5rem; border-radius: 4px; font-family: inherit; font-size: 0.8rem;
    width: 100%;
  }

  /* Claude chat panel */
  .claude-chat {
    display: flex; flex-direction: column; height: 100%;
  }
  .claude-messages {
    flex: 1; overflow-y: auto; padding: 1.5rem;
    display: flex; flex-direction: column; gap: 0.75rem;
  }
  .claude-welcome {
    text-align: center; color: var(--text-dim); padding: 3rem 1rem;
  }
  .claude-welcome h3 {
    font-size: 1.1rem; color: var(--text); margin-bottom: 0.5rem;
  }
  .claude-welcome p { font-size: 0.8rem; margin-bottom: 0.25rem; }
  .claude-examples { color: var(--accent); font-size: 0.75rem !important; margin-top: 0.5rem; }
  .claude-msg {
    max-width: 85%; padding: 0.75rem 1rem; border-radius: 8px;
    font-size: 0.8rem; line-height: 1.5; word-wrap: break-word;
  }
  .claude-msg.user {
    align-self: flex-end; background: var(--accent); color: #fff;
    border-bottom-right-radius: 2px;
  }
  .claude-msg.assistant {
    align-self: flex-start; background: var(--card);
    border: 1px solid var(--card-border); border-bottom-left-radius: 2px;
    max-width: 90%;
  }
  .claude-tool {
    background: rgba(59,130,246,0.08); border: 1px solid rgba(59,130,246,0.15);
    border-radius: 4px; padding: 0.35rem 0.6rem; margin: 0.4rem 0;
    font-size: 0.7rem; display: flex; align-items: center; gap: 0.4rem;
  }
  .claude-tool-name { color: var(--accent); font-weight: 600; }
  .claude-tool-arg { color: var(--text-dim); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .claude-text { white-space: pre-wrap; }
  .claude-meta {
    display: block; margin-top: 0.5rem; padding-top: 0.5rem;
    border-top: 1px solid var(--card-border);
    font-size: 0.65rem; color: var(--text-dim);
  }
  .claude-error { color: var(--red); }
  .claude-typing { color: var(--text-dim); font-style: italic; }
  .claude-input-area {
    display: flex; gap: 0.75rem; padding: 0.75rem 1.5rem;
    background: var(--card); border-top: 1px solid var(--card-border);
    align-items: flex-end;
  }
  .claude-input-area textarea {
    flex: 1; background: var(--bg); border: 1px solid var(--card-border);
    color: var(--text); padding: 0.6rem 0.75rem; border-radius: 6px;
    font-family: inherit; font-size: 0.8rem; resize: none; line-height: 1.4;
  }
  .claude-input-area textarea:focus { outline: none; border-color: var(--accent); }
  .claude-input-area .btn { flex-shrink: 0; }

  /* Rules panel */
  .rules { padding: 1.5rem; overflow-y: auto; }
  .rules-section { margin-bottom: 2.5rem; }
  .rules-section-title {
    font-size: 0.75rem; font-weight: 600; text-transform: uppercase;
    letter-spacing: 1px; color: var(--text-dim); margin-bottom: 1rem;
    padding-bottom: 0.5rem; border-bottom: 1px solid var(--card-border);
  }
  .rules-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;
  }
  .rules-card {
    background: var(--card); border: 1px solid var(--card-border);
    border-radius: 8px; padding: 1.25rem;
  }
  .rules-card-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 1rem;
  }
  .rules-card-title { font-size: 0.95rem; font-weight: 600; }
  .rules-toggle {
    display: flex; align-items: center; gap: 0.4rem; font-size: 0.75rem; color: var(--text-dim);
  }
  .toggle-switch {
    position: relative; width: 32px; height: 18px; cursor: pointer;
  }
  .toggle-switch input { opacity: 0; width: 0; height: 0; }
  .toggle-slider {
    position: absolute; inset: 0; background: #444; border-radius: 18px;
    transition: 0.2s;
  }
  .toggle-slider:before {
    content: ''; position: absolute; width: 12px; height: 12px;
    left: 3px; top: 3px; background: #fff; border-radius: 50%; transition: 0.2s;
  }
  .toggle-switch input:checked + .toggle-slider { background: var(--green); }
  .toggle-switch input:checked + .toggle-slider:before { transform: translateX(14px); }
  .rules-field { margin-bottom: 0.75rem; }
  .rules-field label {
    display: block; font-size: 0.65rem; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px;
  }
  .rules-field input, .rules-field select {
    background: var(--bg); border: 1px solid var(--card-border); color: var(--text);
    padding: 0.35rem 0.6rem; border-radius: 4px; font-family: inherit;
    font-size: 0.82rem; width: 100%;
  }
  .rules-field input:focus, .rules-field select:focus {
    outline: none; border-color: var(--accent);
  }
  .rules-subhead {
    font-size: 0.65rem; color: var(--accent); text-transform: uppercase;
    letter-spacing: 0.5px; margin: 0.75rem 0 0.4rem;
  }
  .rules-card-footer {
    display: flex; justify-content: space-between; align-items: center; margin-top: 1rem;
  }
  .rules-feedback { font-size: 0.75rem; min-height: 1em; }
  .rules-feedback.ok { color: var(--green); }
  .rules-feedback.err { color: var(--red); }
  .btc-field-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.3rem 0; border-bottom: 1px solid rgba(255,255,255,0.04);
    font-size: 0.82rem;
  }
  .btc-field-row:last-child { border-bottom: none; }
  .btc-field-label { color: var(--text-dim); font-size: 0.75rem; }
  .btc-field-val { font-weight: 500; }
  .tier-badge {
    display: inline-block; font-size: 0.6rem; padding: 2px 6px; border-radius: 3px;
    font-weight: 600; margin-right: 3px;
  }
  .tier-on { background: rgba(80,200,120,0.15); color: var(--green); }
  .tier-off { background: rgba(255,100,100,0.1); color: #666; text-decoration: line-through; }
  .rules-stopped {
    font-size: 0.75rem; color: var(--red); margin-top: 0.5rem;
  }
</style>
</head>
<body>

<div class="header">
  <h1>KALSHI PORTAL</h1>
  <div class="tabs" id="tabBar">
    <button class="tab active" data-tab="overview">Overview</button>
    <button class="tab" data-tab="capital">$ Capital</button>
    <button class="tab" data-tab="rules">&#9881; Rules</button>
    <button class="tab" data-tab="claude" style="color:var(--orange)">&gt;_ Claude</button>
    {% for bot_id, bot in bots.items() %}
    <button class="tab" data-tab="{{ bot_id }}">
      <span class="dot" id="dot-{{ bot_id }}"></span>
      {{ bot.short }}
    </button>
    {% endfor %}
  </div>
</div>

<div class="panel-container">
  <!-- Overview panel -->
  <div class="panel active" id="panel-overview">
    <div class="overview">
      <div class="overview-header">
        <h2>Portfolio Overview</h2>
        <div>
          <span class="total-pnl zero" id="totalPnl">$0.00</span>
          <div class="refresh-info" id="refreshInfo">Loading...</div>
        </div>
      </div>
      <div class="bot-cards" id="botCards"></div>
    </div>
  </div>

  <!-- Capital panel -->
  <div class="panel" id="panel-capital">
    <div class="capital">
      <div class="capital-header">
        <h2>Capital Management</h2>
        <div>
          <span class="capital-total" id="capitalTotal">$0.00</span>
          <div class="refresh-info" id="capitalRefresh">Loading...</div>
        </div>
      </div>

      <div class="sub-cards" id="capitalCards"></div>

      <div class="capital-section">
        <h3>Allocate Capital</h3>
        <div class="form-row">
          <div class="form-group">
            <label>Bot</label>
            <select id="allocBot"></select>
          </div>
          <div class="form-group">
            <label>Label</label>
            <input type="text" id="allocLabel" placeholder="e.g. BTC Range">
          </div>
          <div class="form-group">
            <label>Amount ($)</label>
            <input type="number" id="allocAmount" min="0" step="0.01" placeholder="0.00">
          </div>
          <button class="btn btn-green" id="allocBtn" onclick="doAllocate()">Allocate</button>
        </div>
        <div class="feedback" id="allocFeedback"></div>
      </div>

      <div class="capital-section">
        <h3>Transfer Funds</h3>
        <div class="form-row">
          <div class="form-group">
            <label>From</label>
            <select id="xferFrom"></select>
          </div>
          <div class="form-group">
            <label>To</label>
            <select id="xferTo"></select>
          </div>
          <div class="form-group">
            <label>Amount ($)</label>
            <input type="number" id="xferAmount" min="0.01" step="0.01" placeholder="0.00">
          </div>
          <button class="btn btn-primary" id="xferBtn" onclick="doTransfer()">Transfer</button>
        </div>
        <div class="feedback" id="xferFeedback"></div>
      </div>

      <div class="capital-section">
        <h3>Allocations</h3>
        <table class="mgmt-table">
          <thead><tr><th>Bot</th><th>Label</th><th>Allocation</th><th>P&L</th><th>Effective</th><th></th></tr></thead>
          <tbody id="mgmtBody"></tbody>
        </table>
      </div>

      <div class="capital-section">
        <h3>Transfer History</h3>
        <table class="mgmt-table" id="xferHistory">
          <thead><tr><th>Time</th><th>From</th><th>To</th><th>Amount</th></tr></thead>
          <tbody id="xferHistoryBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Rules panel -->
  <div class="panel" id="panel-rules">
    <div class="rules" id="rulesContent">
      <div style="color:var(--text-dim);text-align:center;padding:3rem">Loading rules...</div>
    </div>
  </div>

  <!-- Claude panel -->
  <div class="panel" id="panel-claude">
    <div class="claude-chat">
      <div class="claude-messages" id="claudeMessages">
        <div class="claude-welcome">
          <h3>&gt;_ Claude Code</h3>
          <p>Ask Claude to read, edit, or create files in this project.</p>
          <p class="claude-examples">Try: "Show me the config" &bull; "Add logging to the overview endpoint" &bull; "Fix the proxy timeout handling"</p>
        </div>
      </div>
      <div class="claude-input-area">
        <textarea id="claudeInput" placeholder="Ask Claude to modify code..." rows="2"></textarea>
        <button class="btn btn-primary" id="claudeSend" onclick="sendClaudeMessage()">Send</button>
        <button class="btn" id="claudeNewChat" onclick="resetClaudeChat()" title="Start a new conversation">New Chat</button>
      </div>
    </div>
  </div>

  <!-- Bot iframe panels -->
  {% for bot_id, bot in bots.items() %}
  <div class="panel" id="panel-{{ bot_id }}">
    <div class="iframe-loading" id="loading-{{ bot_id }}">Loading {{ bot.name }}...</div>
  </div>
  {% endfor %}
</div>

<script>
const BOTS = {{ bots | tojson }};
const BOT_IDS = Object.keys(BOTS);
let overviewData = null;
let loadedIframes = {};

// Tab switching
document.getElementById('tabBar').addEventListener('click', function(e) {
  const tab = e.target.closest('.tab');
  if (!tab) return;
  const target = tab.dataset.tab;

  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  tab.classList.add('active');
  document.getElementById('panel-' + target).classList.add('active');

  // Lazy-load iframe (skip non-bot tabs)
  if (target !== 'overview' && target !== 'capital' && target !== 'claude' && target !== 'rules' && !loadedIframes[target]) {
    loadIframe(target);
  }
  if (target === 'rules') loadRules();
});

function loadIframe(botId) {
  loadedIframes[botId] = true;
  const panel = document.getElementById('panel-' + botId);
  const loading = document.getElementById('loading-' + botId);
  const iframe = document.createElement('iframe');
  iframe.src = '/bot/' + botId + '/';
  iframe.onload = function() {
    if (loading) loading.style.display = 'none';
  };
  panel.appendChild(iframe);
}

// Overview rendering
function formatPnl(val) {
  const sign = val >= 0 ? '+' : '';
  return sign + '$' + Math.abs(val).toFixed(2);
}

function pnlClass(val) {
  if (val > 0) return 'positive';
  if (val < 0) return 'negative';
  return 'zero';
}

function renderOverview(data) {
  overviewData = data;

  // Total P&L
  const totalEl = document.getElementById('totalPnl');
  totalEl.textContent = formatPnl(data.total_pnl);
  totalEl.className = 'total-pnl ' + pnlClass(data.total_pnl);

  // Refresh info
  document.getElementById('refreshInfo').textContent =
    'Updated ' + new Date().toLocaleTimeString();

  // Bot cards
  const container = document.getElementById('botCards');
  container.innerHTML = '';

  for (const [botId, bot] of Object.entries(data.bots)) {
    const cfg = BOTS[botId] || {};
    const card = document.createElement('div');
    card.className = 'bot-card';
    card.style.borderLeftColor = bot.color || cfg.color || '#666';

    const isHealthy = bot.healthy;
    const hasError = !!bot.error;

    let statsHtml = '';
    if (hasError) {
      statsHtml = '<div class="error-msg">' + bot.error + '</div>';
    } else {
      statsHtml = '<div class="bot-stats">';
      statsHtml += '<div class="stat-item"><div class="stat-label">P&L</div>' +
        '<div class="stat-value ' + pnlClass(bot.pnl) + '">' + formatPnl(bot.pnl) + '</div></div>';
      statsHtml += '<div class="stat-item"><div class="stat-label">Mode</div>' +
        '<div class="stat-value">' + (bot.mode || 'N/A') + '</div></div>';

      if (bot.win_rate !== undefined) {
        statsHtml += '<div class="stat-item"><div class="stat-label">Win Rate</div>' +
          '<div class="stat-value">' + bot.win_rate + '%</div></div>';
      }
      if (bot.completed !== undefined) {
        statsHtml += '<div class="stat-item"><div class="stat-label">Trades</div>' +
          '<div class="stat-value">' + bot.completed +
          (bot.wins !== undefined ? ' (' + bot.wins + 'W)' : '') + '</div></div>';
      }
      if (bot.open_positions !== undefined) {
        statsHtml += '<div class="stat-item"><div class="stat-label">Open</div>' +
          '<div class="stat-value">' + bot.open_positions + '</div></div>';
      }
      if (bot.daily_trades !== undefined) {
        statsHtml += '<div class="stat-item"><div class="stat-label">Daily Trades</div>' +
          '<div class="stat-value">' + bot.daily_trades + '</div></div>';
      }
      if (bot.running !== undefined) {
        statsHtml += '<div class="stat-item"><div class="stat-label">Running</div>' +
          '<div class="stat-value">' + (bot.running ? 'Yes' : 'No') + '</div></div>';
      }
      statsHtml += '</div>';
    }

    const badgeClass = hasError ? 'unknown' : (isHealthy ? 'healthy' : 'unhealthy');
    const badgeText = hasError ? 'UNREACHABLE' : (isHealthy ? 'HEALTHY' : 'UNHEALTHY');

    card.innerHTML =
      '<div class="bot-card-header">' +
        '<span class="bot-card-title">' + bot.name + '</span>' +
        '<span class="bot-badge ' + badgeClass + '">' + badgeText + '</span>' +
      '</div>' +
      statsHtml +
      '<button class="open-btn" data-bot="' + botId + '">Open Dashboard &rarr;</button>';

    container.appendChild(card);
  }

  // Update tab dots
  for (const [botId, bot] of Object.entries(data.bots)) {
    const dot = document.getElementById('dot-' + botId);
    if (dot) {
      dot.className = 'dot ' + (bot.error ? 'unhealthy' : (bot.healthy ? 'healthy' : 'unhealthy'));
    }
  }
}

// Open bot dashboard from card
document.getElementById('botCards').addEventListener('click', function(e) {
  const btn = e.target.closest('.open-btn');
  if (!btn) return;
  const botId = btn.dataset.bot;
  // Activate the tab
  const tab = document.querySelector('.tab[data-tab="' + botId + '"]');
  if (tab) tab.click();
});

// Fetch overview data
function fetchOverview() {
  fetch('/api/overview')
    .then(r => r.json())
    .then(data => renderOverview(data))
    .catch(err => {
      document.getElementById('refreshInfo').textContent = 'Error: ' + err.message;
    });
}

// Initial load + auto-refresh
fetchOverview();
setInterval(fetchOverview, 5000);

// ---- Capital tab (virtual ledger) ----
let capitalData = null;
let capitalInterval = null;

// Auto-refresh capital when tab is active
document.getElementById('tabBar').addEventListener('click', function(e) {
  const tab = e.target.closest('.tab');
  if (!tab) return;
  if (tab.dataset.tab === 'capital') {
    fetchCapital();
    fetchTransferHistory();
    if (!capitalInterval) capitalInterval = setInterval(function() { fetchCapital(); fetchTransferHistory(); }, 10000);
  } else {
    if (capitalInterval) { clearInterval(capitalInterval); capitalInterval = null; }
  }
});

function centsToStr(c) { return '$' + (Math.abs(c) / 100).toFixed(2); }
function centsToSigned(c) { return (c >= 0 ? '+' : '-') + centsToStr(c); }

function fetchCapital() {
  fetch('/api/capital')
    .then(r => { if (!r.ok) throw new Error('Error ' + r.status); return r.json(); })
    .then(data => { capitalData = data; renderCapital(); })
    .catch(err => {
      document.getElementById('capitalRefresh').textContent = err.message;
    });
}

function renderCapital() {
  if (!capitalData) return;
  const d = capitalData;

  // Header total
  const totalEl = document.getElementById('capitalTotal');
  if (d.real_balance !== null) {
    totalEl.textContent = '$' + (d.real_balance / 100).toFixed(2);
    totalEl.className = 'capital-total ' + pnlClass(d.real_balance);
  } else {
    totalEl.textContent = '$' + (d.total_allocated / 100).toFixed(2) + ' allocated';
    totalEl.className = 'capital-total';
  }
  document.getElementById('capitalRefresh').textContent = 'Updated ' + new Date().toLocaleTimeString();

  // Cards: one per account + unallocated
  const container = document.getElementById('capitalCards');
  container.innerHTML = '';

  // Unallocated card
  const unCard = document.createElement('div');
  unCard.className = 'sub-card';
  unCard.style.borderLeftColor = 'var(--accent)';
  var unBal, unLabel, unSub;
  if (d.real_balance !== null) {
    unBal = d.unallocated !== null ? d.unallocated : 0;
    unLabel = '$' + (Math.abs(unBal) / 100).toFixed(2);
    unSub = 'Real balance ($' + (d.real_balance / 100).toFixed(2) + ') minus allocations ($' + (d.total_allocated / 100).toFixed(2) + ')';
  } else {
    unBal = 0;
    unLabel = 'No Kalshi API key';
    unSub = 'Total allocated: $' + (d.total_allocated / 100).toFixed(2) + ' across ' + d.accounts.length + ' bot' + (d.accounts.length !== 1 ? 's' : '') + '. Connect Kalshi API to see remaining balance.';
  }
  unCard.innerHTML =
    '<div class="sub-card-header">' +
      '<span class="sub-card-label">Unallocated</span>' +
      '<span class="sub-card-badge">POOL</span>' +
    '</div>' +
    '<div class="sub-card-balance ' + pnlClass(unBal) + '">' + unLabel + '</div>' +
    '<div class="sub-card-bot">' + unSub + '</div>';
  container.appendChild(unCard);

  // Per-bot cards
  d.accounts.forEach(function(a) {
    const card = document.createElement('div');
    card.className = 'sub-card';
    card.style.borderLeftColor = a.color || '#888';
    card.innerHTML =
      '<div class="sub-card-header">' +
        '<span class="sub-card-label">' + a.label + '</span>' +
        '<span class="sub-card-badge">' + a.id + '</span>' +
      '</div>' +
      '<div class="sub-card-balance">' + centsToStr(a.effective) + '</div>' +
      '<div class="bot-stats" style="margin-top:0.5rem">' +
        '<div class="stat-item"><div class="stat-label">Allocation</div><div class="stat-value">' + centsToStr(a.allocation) + '</div></div>' +
        '<div class="stat-item"><div class="stat-label">P&L</div><div class="stat-value ' + pnlClass(a.pnl) + '">' + centsToSigned(a.pnl) + '</div></div>' +
      '</div>';
    container.appendChild(card);
  });

  // Allocate form: populate bot dropdown (only bots not yet allocated)
  const allocatedIds = d.accounts.map(function(a) { return a.id; });
  const allocSel = document.getElementById('allocBot');
  const prevAlloc = allocSel.value;
  allocSel.innerHTML = '';
  BOT_IDS.forEach(function(id) {
    if (allocatedIds.indexOf(id) === -1) {
      allocSel.innerHTML += '<option value="' + id + '">' + BOTS[id].name + '</option>';
    }
  });
  // Also allow re-allocating existing bots (to update amount)
  d.accounts.forEach(function(a) {
    allocSel.innerHTML += '<option value="' + a.id + '">' + a.label + ' (update)</option>';
  });
  if (prevAlloc) allocSel.value = prevAlloc;

  // Auto-fill label when bot selected
  allocSel.onchange = function() {
    const id = allocSel.value;
    if (BOTS[id]) document.getElementById('allocLabel').value = BOTS[id].name;
  };
  // Trigger initial fill if empty
  if (!document.getElementById('allocLabel').value && allocSel.value && BOTS[allocSel.value]) {
    document.getElementById('allocLabel').value = BOTS[allocSel.value].name;
  }

  // Transfer dropdowns: all accounts + unallocated
  ['xferFrom', 'xferTo'].forEach(function(selId) {
    const sel = document.getElementById(selId);
    const prev = sel.value;
    sel.innerHTML = '<option value="unallocated">Unallocated</option>';
    d.accounts.forEach(function(a) {
      sel.innerHTML += '<option value="' + a.id + '">' + a.label + ' (' + centsToStr(a.allocation) + ')</option>';
    });
    if (prev) sel.value = prev;
  });

  // Management table
  const tbody = document.getElementById('mgmtBody');
  tbody.innerHTML = '';
  d.accounts.forEach(function(a) {
    const tr = document.createElement('tr');
    tr.innerHTML =
      '<td>' + a.id + '</td>' +
      '<td>' + a.label + '</td>' +
      '<td>' + centsToStr(a.allocation) + '</td>' +
      '<td class="' + pnlClass(a.pnl) + '">' + centsToSigned(a.pnl) + '</td>' +
      '<td>' + centsToStr(a.effective) + '</td>' +
      '<td><button class="btn btn-red btn-small" onclick="removeAllocation(\'' + a.id + '\')">Remove</button></td>';
    tbody.appendChild(tr);
  });
  if (d.accounts.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="color:var(--text-dim);text-align:center">No allocations yet</td></tr>';
  }
}

function doAllocate() {
  const botId = document.getElementById('allocBot').value;
  const label = document.getElementById('allocLabel').value.trim();
  const amt = parseFloat(document.getElementById('allocAmount').value);
  const fb = document.getElementById('allocFeedback');
  if (!botId) { fb.textContent = 'Select a bot'; fb.className = 'feedback err'; return; }
  if (!label) { fb.textContent = 'Label is required'; fb.className = 'feedback err'; return; }
  if (isNaN(amt) || amt < 0) { fb.textContent = 'Enter a valid amount'; fb.className = 'feedback err'; return; }
  document.getElementById('allocBtn').disabled = true;
  fetch('/api/capital/allocate', {
    method: 'POST', headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({bot_id: botId, label: label, amount: amt})
  })
  .then(r => r.json().then(d => ({ok: r.ok, data: d})))
  .then(function(res) {
    fb.textContent = res.ok ? 'Allocated $' + amt.toFixed(2) + ' to ' + label : (res.data.error || 'Failed');
    fb.className = 'feedback ' + (res.ok ? 'ok' : 'err');
    if (res.ok) { document.getElementById('allocAmount').value = ''; fetchCapital(); fetchTransferHistory(); }
  })
  .catch(e => { fb.textContent = e.message; fb.className = 'feedback err'; })
  .finally(() => { document.getElementById('allocBtn').disabled = false; });
}

function doTransfer() {
  const from = document.getElementById('xferFrom').value;
  const to = document.getElementById('xferTo').value;
  const amt = parseFloat(document.getElementById('xferAmount').value);
  const fb = document.getElementById('xferFeedback');
  if (!amt || amt <= 0) { fb.textContent = 'Enter a valid amount'; fb.className = 'feedback err'; return; }
  if (from === to) { fb.textContent = 'From and To must differ'; fb.className = 'feedback err'; return; }
  const fromLabel = from === 'unallocated' ? 'Unallocated' : from;
  const toLabel = to === 'unallocated' ? 'Unallocated' : to;
  if (!confirm('Transfer $' + amt.toFixed(2) + ' from ' + fromLabel + ' to ' + toLabel + '?')) return;
  document.getElementById('xferBtn').disabled = true;
  fetch('/api/capital/transfer', {
    method: 'POST', headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({from: from, to: to, amount: amt})
  })
  .then(r => r.json().then(d => ({ok: r.ok, data: d})))
  .then(function(res) {
    fb.textContent = res.ok ? 'Transfer complete' : (res.data.error || 'Transfer failed');
    fb.className = 'feedback ' + (res.ok ? 'ok' : 'err');
    if (res.ok) { document.getElementById('xferAmount').value = ''; fetchCapital(); fetchTransferHistory(); }
  })
  .catch(e => { fb.textContent = e.message; fb.className = 'feedback err'; })
  .finally(() => { document.getElementById('xferBtn').disabled = false; });
}

function removeAllocation(botId) {
  if (!confirm('Remove allocation for ' + botId + '? Funds return to unallocated pool.')) return;
  fetch('/api/capital/' + botId, {method: 'DELETE'})
    .then(r => { if (!r.ok) throw new Error('Remove failed'); return r.json(); })
    .then(() => fetchCapital())
    .catch(e => alert(e.message));
}

function fetchTransferHistory() {
  fetch('/api/capital/transfers?limit=20')
    .then(r => { if (!r.ok) throw new Error('Error'); return r.json(); })
    .then(function(data) {
      const tbody = document.getElementById('xferHistoryBody');
      tbody.innerHTML = '';
      const xfers = data.transfers || [];
      if (xfers.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="color:var(--text-dim);text-align:center">No transfers yet</td></tr>';
        return;
      }
      xfers.forEach(function(t) {
        const tr = document.createElement('tr');
        const ts = new Date(t.ts).toLocaleString();
        const fromLabel = t.from === 'unallocated' ? 'Unallocated' : t.from;
        const toLabel = t.to === 'unallocated' ? 'Unallocated' : t.to;
        tr.innerHTML =
          '<td>' + ts + '</td>' +
          '<td>' + fromLabel + '</td>' +
          '<td>' + toLabel + '</td>' +
          '<td>' + centsToStr(t.amount) + '</td>';
        tbody.appendChild(tr);
      });
    })
    .catch(function() {});
}

// ---- Claude Code integration ----
var claudeMessages = [];
var claudeRunning = false;
var claudeSessionId = null;  // Tracks the conversation session for memory

function _esc(str) {
  var d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function addClaudeMsg(role, html) {
  claudeMessages.push({role: role, html: html});
  renderClaudeMsgs();
}

function renderClaudeMsgs() {
  var container = document.getElementById('claudeMessages');
  // Remove welcome message on first interaction
  var welcome = container.querySelector('.claude-welcome');
  if (welcome && claudeMessages.length > 0) welcome.remove();

  // Rebuild messages
  while (container.children.length > claudeMessages.length) {
    container.removeChild(container.lastChild);
  }
  for (var i = 0; i < claudeMessages.length; i++) {
    var msg = claudeMessages[i];
    var el = container.children[i];
    if (!el) {
      el = document.createElement('div');
      el.className = 'claude-msg ' + msg.role;
      container.appendChild(el);
    }
    el.innerHTML = msg.html;
  }
  container.scrollTop = container.scrollHeight;
}

async function sendClaudeMessage() {
  if (claudeRunning) return;
  var input = document.getElementById('claudeInput');
  var prompt = input.value.trim();
  if (!prompt) return;

  input.value = '';
  addClaudeMsg('user', _esc(prompt));

  claudeRunning = true;
  _updateClaudeUI();

  // Placeholder for assistant response
  var aIdx = claudeMessages.length;
  claudeMessages.push({role: 'assistant', html: '<span class="claude-typing">Thinking...</span>'});
  renderClaudeMsgs();

  var textContent = '';
  var toolUses = [];
  var meta = null;

  try {
    var response = await fetch('/api/claude', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({prompt: prompt, session_id: claudeSessionId || ''})
    });

    if (!response.ok) {
      var err = await response.json();
      claudeMessages[aIdx].html = '<span class="claude-error">' + _esc(err.error || 'Request failed') + '</span>';
      renderClaudeMsgs();
      return;
    }

    var reader = response.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';

    while (true) {
      var chunk = await reader.read();
      if (chunk.done) break;

      buffer += decoder.decode(chunk.value, {stream: true});
      var lines = buffer.split('\n');
      buffer = lines.pop();

      for (var li = 0; li < lines.length; li++) {
        var line = lines[li];
        if (!line.startsWith('data: ')) continue;
        var raw = line.slice(6);
        if (raw === '[DONE]') continue;

        try {
          var evt = JSON.parse(raw);
          if (evt.type === 'assistant' && evt.message && evt.message.content) {
            evt.message.content.forEach(function(block) {
              if (block.type === 'text') {
                textContent += block.text;
              } else if (block.type === 'tool_use') {
                toolUses.push({name: block.name, input: block.input || {}});
              }
            });
          } else if (evt.type === 'result') {
            if (evt.result && !textContent) textContent = evt.result;
            if (evt.session_id) claudeSessionId = evt.session_id;
            if (evt.cost_usd !== undefined) {
              meta = {cost: evt.cost_usd, duration: evt.duration_ms};
            }
          } else if (evt.type === 'error') {
            textContent += '\nError: ' + (evt.error || 'Unknown error');
          }
        } catch (e) {
          // Not JSON ‚Äî append as raw text
          textContent += raw + '\n';
        }

        claudeMessages[aIdx].html = _renderAssistant(textContent, toolUses, meta);
        renderClaudeMsgs();
      }
    }

    // Final render
    if (!textContent && toolUses.length === 0) {
      textContent = '(No output)';
    }
    claudeMessages[aIdx].html = _renderAssistant(textContent, toolUses, meta);
    renderClaudeMsgs();

  } catch (e) {
    claudeMessages[aIdx].html = '<span class="claude-error">Connection error: ' + _esc(e.message) + '</span>';
    renderClaudeMsgs();
  } finally {
    claudeRunning = false;
    _updateClaudeUI();
  }
}

function _renderAssistant(text, tools, meta) {
  var html = '';
  for (var i = 0; i < tools.length; i++) {
    var t = tools[i];
    html += '<div class="claude-tool"><span class="claude-tool-name">' + _esc(t.name) + '</span>';
    if (t.input.file_path) html += '<span class="claude-tool-arg">' + _esc(t.input.file_path) + '</span>';
    else if (t.input.command) html += '<span class="claude-tool-arg">' + _esc(t.input.command.substring(0, 100)) + '</span>';
    else if (t.input.pattern) html += '<span class="claude-tool-arg">' + _esc(t.input.pattern) + '</span>';
    html += '</div>';
  }
  if (text) {
    html += '<div class="claude-text">' + _esc(text).replace(/\n/g, '<br>') + '</div>';
  }
  if (meta) {
    html += '<div class="claude-meta">Cost: $' + meta.cost.toFixed(4) + ' &bull; ' + (meta.duration / 1000).toFixed(1) + 's</div>';
  }
  return html || '<span class="claude-typing">Thinking...</span>';
}

function _updateClaudeUI() {
  document.getElementById('claudeSend').disabled = claudeRunning;
  document.getElementById('claudeInput').disabled = claudeRunning;
  document.getElementById('claudeInput').placeholder =
    claudeRunning ? 'Claude is working...' : 'Ask Claude to modify code...';
}

function resetClaudeChat() {
  claudeMessages = [];
  claudeSessionId = null;
  var container = document.getElementById('claudeMessages');
  container.innerHTML = '<div class="claude-welcome"><h3>&gt;_ Claude Code</h3>'
    + '<p>Ask Claude to read, edit, or create files in this project.</p>'
    + '<p class="claude-examples">Try: "Show me the config" &bull; "Add logging to the overview endpoint" &bull; "Fix the proxy timeout handling"</p></div>';
}

// Enter to send (Shift+Enter for newline)
document.getElementById('claudeInput').addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendClaudeMessage();
  }
});

// ============================================================
// RULES TAB
// ============================================================
const SPORT_LABELS = {nba:'NBA', soccer:'Soccer', mlb:'MLB', nfl:'NFL', nhl:'NHL'};
const SPORT_COLORS = {nba:'#58a6ff', soccer:'#50c878', mlb:'#f7931a', nfl:'#8b5cf6', nhl:'#06b6d4'};
let _rulesLoaded = false;

async function loadRules() {
  if (_rulesLoaded) return;
  _rulesLoaded = true;

  const el = document.getElementById('rulesContent');

  // Fetch sports config + BTC Range config + BTC Momentum config in parallel
  const [sportsRes, btcRes, momRes] = await Promise.allSettled([
    fetch('/proxy/sports-arb/api/config', {headers: {'Authorization': 'Basic ' + btoa('admin:changeme123')}}).then(r => r.ok ? r.json() : null),
    fetch('/proxy/btc-range/api/bot/config').then(r => r.ok ? r.json() : null),
    fetch('/proxy/btc-momentum/api/bot/config').then(r => r.ok ? r.json() : null),
  ]);

  const sportsConfig = sportsRes.status === 'fulfilled' ? sportsRes.value : null;
  const btcConfig    = btcRes.status === 'fulfilled' ? btcRes.value : null;
  const momConfig    = momRes.status === 'fulfilled' ? momRes.value : null;

  el.innerHTML = renderRules(sportsConfig, btcConfig, momConfig);
}

function renderRules(sports, btc, mom) {
  let html = '';

  // ---- Sports Arb Section ----
  html += '<div class="rules-section">';
  html += '<div class="rules-section-title">Sports Arb ‚Äî Trading Rules</div>';
  if (!sports) {
    html += '<div style="color:var(--red);font-size:.85rem">Could not reach sports-arb config endpoint</div>';
  } else {
    html += '<div class="rules-grid">';
    const order = ['nba','soccer','mlb','nfl','nhl'];
    for (const sport of order) {
      if (!sports[sport]) continue;
      html += renderSportCard(sport, sports[sport]);
    }
    html += '</div>';
  }
  html += '</div>';

  // ---- BTC Bots Section ----
  html += '<div class="rules-section">';
  html += '<div class="rules-section-title">BTC 15-Min Arb ‚Äî Bot Config</div>';
  html += '<div class="rules-grid">';
  html += renderBtcCard('BTC Range', '#f7931a', btc, false);
  html += renderBtcCard('BTC Momentum', '#ff6b6b', mom, true);
  html += '</div>';
  html += '</div>';

  return html;
}

function renderSportCard(sport, cfg) {
  const color = SPORT_COLORS[sport] || '#fff';
  const label = SPORT_LABELS[sport] || sport.toUpperCase();
  const pt = cfg.profit_target || {};
  const ed = cfg.edge_decay || {};

  return `<div class="rules-card" style="border-top:3px solid ${color}">
    <div class="rules-card-header">
      <span class="rules-card-title">${label}</span>
      <label class="toggle-switch" title="Enabled">
        <input type="checkbox" ${cfg.enabled !== false ? 'checked' : ''} onchange="saveSportField('${sport}','enabled',this.checked)">
        <span class="toggle-slider"></span>
      </label>
    </div>

    <div class="rules-subhead">Price &amp; Edge</div>
    <div class="rules-field">
      <label>Min Edge (%)</label>
      <input type="number" step="0.5" min="0" max="50" value="${+(cfg.min_edge*100).toFixed(1)}"
        onchange="saveSportField('${sport}','min_edge',parseFloat(this.value)/100)">
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem">
      <div class="rules-field">
        <label>Min Price (¬¢)</label>
        <input type="number" step="1" min="1" max="99" value="${cfg.min_price||15}"
          onchange="saveSportField('${sport}','min_price',parseInt(this.value))">
      </div>
      <div class="rules-field">
        <label>Max Price (¬¢)</label>
        <input type="number" step="1" min="1" max="99" value="${cfg.max_price||90}"
          onchange="saveSportField('${sport}','max_price',parseInt(this.value))">
      </div>
    </div>

    <div class="rules-subhead">Profit Target</div>
    <div class="rules-field">
      <label>Mode</label>
      <select onchange="saveSportField('${sport}','profit_target',{...getProfitTarget('${sport}'),mode:this.value})">
        ${['dynamic','fixed','fixed_by_half'].map(m=>`<option value="${m}"${pt.mode===m?' selected':''}>${m}</option>`).join('')}
      </select>
    </div>
    ${pt.mode==='dynamic' ? `
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem">
      <div class="rules-field">
        <label>Multiplier</label>
        <input type="number" step="0.05" min="0.1" max="2" value="${pt.multiplier||0.5}"
          onchange="saveSportField('${sport}','profit_target',{...getProfitTarget('${sport}'),multiplier:parseFloat(this.value)})">
      </div>
      <div class="rules-field">
        <label>Min Profit (¬¢)</label>
        <input type="number" step="1" min="1" max="20" value="${pt.min_profit||2}"
          onchange="saveSportField('${sport}','profit_target',{...getProfitTarget('${sport}'),min_profit:parseInt(this.value)})">
      </div>
    </div>` : pt.mode==='fixed_by_half' ? `
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem">
      <div class="rules-field">
        <label>1st Half (¬¢)</label>
        <input type="number" step="1" min="1" value="${pt.profit_1h||15}"
          onchange="saveSportField('${sport}','profit_target',{...getProfitTarget('${sport}'),profit_1h:parseInt(this.value)})">
      </div>
      <div class="rules-field">
        <label>2nd Half (¬¢)</label>
        <input type="number" step="1" min="1" value="${pt.profit_2h||25}"
          onchange="saveSportField('${sport}','profit_target',{...getProfitTarget('${sport}'),profit_2h:parseInt(this.value)})">
      </div>
      <div class="rules-field">
        <label>Tie (¬¢)</label>
        <input type="number" step="1" min="1" value="${pt.tie_profit||15}"
          onchange="saveSportField('${sport}','profit_target',{...getProfitTarget('${sport}'),tie_profit:parseInt(this.value)})">
      </div>
    </div>` : ''}

    <div class="rules-subhead">Edge Decay</div>
    <div style="display:flex;align-items:center;gap:.5rem;margin-bottom:.5rem">
      <label class="toggle-switch" title="Enable edge decay">
        <input type="checkbox" ${ed.enabled ? 'checked' : ''}
          onchange="saveSportField('${sport}','edge_decay',{...getEdgeDecay('${sport}'),enabled:this.checked})">
        <span class="toggle-slider"></span>
      </label>
      <span style="font-size:.75rem;color:var(--text-dim)">Tighten before game start</span>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem">
      <div class="rules-field">
        <label>Tighten Hours</label>
        <input type="number" step="0.5" min="0.5" max="12" value="${ed.tighten_hours||2}"
          onchange="saveSportField('${sport}','edge_decay',{...getEdgeDecay('${sport}'),tighten_hours:parseFloat(this.value)})">
      </div>
      <div class="rules-field">
        <label>Tighten Factor</label>
        <input type="number" step="0.05" min="0.1" max="1" value="${ed.tighten_factor||0.7}"
          onchange="saveSportField('${sport}','edge_decay',{...getEdgeDecay('${sport}'),tighten_factor:parseFloat(this.value)})">
      </div>
    </div>

    <div class="rules-card-footer">
      <span class="rules-feedback" id="fb-${sport}"></span>
    </div>
  </div>`;
}

function btcRow(label, val, desc) {
  return `<div class="btc-field-row">
    <span class="btc-field-label" title="${desc}">${label} <span style="color:#555;font-size:.6rem">‚ìò</span></span>
    <span class="btc-field-val">${val}</span>
  </div>`;
}
function btcSection(title) {
  return `<div class="rules-subhead">${title}</div>`;
}

function renderBtcCard(name, color, cfg, isMomentum) {
  if (!cfg) {
    return `<div class="rules-card" style="border-top:3px solid ${color}">
      <div class="rules-card-header"><span class="rules-card-title">${name}</span></div>
      <div class="rules-stopped">${isMomentum ? '‚èπ STOPPED ‚Äî backtest showed no edge at S=1-2 (46-49% WR). Do not restart without new strategy.' : 'Unreachable'}</div>
    </div>`;
  }
  const tiers = cfg.enabled_tiers || {};
  const tierOrder = ['sniper','standard','volume','micro','nano'];
  const tierDesc = {
    sniper:   'Strongest signal: S‚â•4 + stacking confirms. Largest size (3√ó base).',
    standard: 'Good signal: S‚â•4 with moderate stacking. Normal size (1√ó base).',
    volume:   'Volume signal: high liquidity window. Reduced size (0.5√ó base).',
    micro:    'Weak signal. Very small size. Currently OFF.',
    nano:     'Minimal signal. Tiny size. Currently OFF.',
  };
  const sz = cfg.asset_sizes || {};
  const ex = cfg.smart_exit_tiers || [];

  const tierBadges = tierOrder.map(t =>
    `<span class="tier-badge ${tiers[t]?'tier-on':'tier-off'}" title="${tierDesc[t]||''}">${t}</span>`
  ).join('');

  return `<div class="rules-card" style="border-top:3px solid ${color}">
    <div class="rules-card-header">
      <span class="rules-card-title">${name}</span>
      <span class="sub-card-badge">${(cfg.mode||'?').toUpperCase()}</span>
    </div>

    ${btcSection('üìä Signal Filter ‚Äî When to look for a trade')}
    ${btcRow('Streak Threshold', `‚â• ${cfg.streak_threshold ?? '?'} consecutive same-direction 15-min windows`,
      'Bot only considers entering if the last N candles all closed in the same direction (all YES or all NO). Lower = more trades but weaker edge. Raised from 3‚Üí4 after backtesting showed S=1-3 is near coin-flip.')}
    ${btcRow('Signal Scorer', cfg.use_scorer ? '‚úì Enabled' : '‚úó Disabled',
      'Multi-factor scoring system that rates the setup quality. Uses time-of-day bias, cross-asset correlation, Bollinger Bands, displacement, liquidity sweeps, and 5m microstructure to assign a tier (SNIPER/STANDARD/VOLUME/SKIP).')}
    ${btcRow('Stacking Signals', cfg.use_stacking ? '‚úì Enabled' : '‚úó Disabled',
      'Boost or kill a trade based on stacked confirmation signals: time-of-day historical bias, cross-asset agreement (BTC+ETH+SOL), Bollinger Band squeeze, displacement candle, order block sweep. More stacked signals = higher tier.')}
    ${btcRow('Candle Signals', cfg.use_candle_signals ? '‚úì Enabled' : '‚úó Disabled',
      '1-minute intra-window candle analysis for extra entry confirmation. Looks for 5m direction, 3-bar momentum blocks, order flow imbalance (OFI), and pullback setups.')}
    ${btcRow('Candle Max Entry', `‚â§ ${((cfg.candle_max_entry||0)*100).toFixed(0)}¬¢`,
      'Candle signal entries are only taken if the contract is priced at or below this level. Prevents buying overpriced contracts even with a good candle signal.')}
    ${btcRow('Candle Min Confidence', `‚â• ${((cfg.candle_min_confidence||0)*100).toFixed(0)}%`,
      'Minimum ML model confidence score required to act on a candle signal. Below this threshold the signal is ignored.')}
    ${btcRow('Active Tiers', `<span style="line-height:2">${tierBadges}</span>`,
      'Which signal quality tiers are allowed to trade. Hover each badge for details. Disabled tiers (MICRO/NANO) are skipped even if the signal fires.')}

    ${btcSection('üìê Position Sizing ‚Äî How much to trade')}
    ${btcRow('Base Contracts', `${cfg.base_contracts ?? '?'} contracts`,
      'The standard position size for a STANDARD-tier signal. Other tiers scale off this: SNIPER = 3√ó, VOLUME = 0.5√ó.')}
    ${btcRow('Asset Multipliers', Object.entries(sz).map(([a,v])=>`${a.toUpperCase()} √ó${v}`).join(' &nbsp;|&nbsp;') || '‚Äî',
      'Per-asset scaling applied on top of the tier size. BTC gets full size (√ó1.0), ETH and SOL are half-sized (√ó0.5) due to lower liquidity.')}
    ${btcRow('Max Open Positions', `${cfg.max_open_positions ?? '?'} across all assets`,
      'Hard cap on total simultaneous open positions. Prevents over-exposure if many signals fire at once.')}

    ${btcSection('üéØ Entry Execution ‚Äî How to get filled')}
    ${btcRow('Target Entry Price', `~${((cfg.entry_price||0)*100).toFixed(0)}¬¢`,
      'The ideal contract price to buy at. The patience and ladder systems work around this target to try to get a better fill.')}
    ${btcRow('Patience Entry', cfg.use_patience ? '‚úì Enabled' : '‚úó Disabled',
      'Instead of hitting the ask immediately, the bot waits up to patience_max_secs for the price to improve before submitting the order. Avoids paying the spread on fast moves.')}
    ${btcRow('Patience Window', `${cfg.patience_base_secs ?? '?'}s base / ${cfg.patience_max_secs ?? '?'}s max`,
      'How long to wait for a better price. The bot starts with the base window and extends up to the max if price hasn\'t improved enough.')}
    ${btcRow('Min Price Improvement', `${((cfg.min_improvement||0)*100).toFixed(0)}¬¢ to trigger patience`,
      'The bid must be at least this much below the current ask before patience kicks in. If the spread is already tight, skip patience and buy immediately.')}
    ${btcRow('Great Price Threshold', `${((cfg.great_price_improvement||0)*100).toFixed(0)}¬¢ improvement`,
      'If the price improves by this much during the patience window, the bot buys immediately rather than waiting the full window.')}
    ${btcRow('Ladder Orders', cfg.use_ladder ? '‚úì Enabled' : '‚úó Disabled',
      'Instead of one order, splits the position into multiple limit orders at different price levels. Improves average fill price on illiquid contracts.')}
    ${btcRow('Ladder Levels', `${cfg.ladder_levels ?? '?'} orders`,
      'How many price levels to split the order across. E.g. 3 levels = 3 separate limit orders.')}
    ${btcRow('Ladder Spread', `${((cfg.ladder_spread||0)*100).toFixed(0)}¬¢ between levels`,
      'Price gap between each ladder level. E.g. spread=3¬¢ with 3 levels ‚Üí orders at target, target-3¬¢, target-6¬¢.')}

    ${btcSection('üîí Lock Structure ‚Äî Reducing downside')}
    ${btcRow('Lock Trade', cfg.use_lock ? '‚úì Enabled' : '‚úó Disabled',
      'When the main position is profitable, the bot buys the opposite side at a very low price (lock_target). This creates an asymmetric structure: win on one side regardless of outcome, capping max loss.')}
    ${btcRow('Lock Target Price', `‚â§ ${((cfg.lock_target||0)*100).toFixed(0)}¬¢`,
      'Only buy the lock if the opposite side is priced at or below this level. E.g. 10¬¢ means "buy the NO at 10¬¢ or less to lock in a guaranteed profit."')}

    ${btcSection('üö™ Smart Exit ‚Äî When to sell')}
    ${btcRow('Trailing Take-Profit', `Sell ALL if bid drops ${((cfg.smart_exit_trail_pct||0)*100).toFixed(0)}% from peak`,
      `Only activates once the bid has reached at least ${((cfg.smart_exit_min_peak||0)*100).toFixed(0)}¬¢. Tracks the highest bid seen; if it falls ${((cfg.smart_exit_trail_pct||0)*100).toFixed(0)}% from that peak, sell everything immediately.`)}
    ${ex.map((t,i) => btcRow(`Profit Tier ${i+1}`,
      `Sell ${(t.sell_fraction*100).toFixed(0)}% when profit ‚â• ${(t.profit_pct*100).toFixed(0)}% of max possible`,
      'Staged exit: locks in partial profits before the full trailing stop fires. Tier 1 sells half early, Tier 2 exits the rest.'
    )).join('')}
    ${btcRow('Time-Based Exit', `Sell if profitable with ‚â§ ${cfg.smart_exit_time_secs ?? '?'}s left in window`,
      'If a position is in profit and the 15-min window is almost over, sell now rather than risk settlement going against you.')}
    ${btcRow('Spot Reversal Exit', `Sell if Binance spot drops ${((cfg.smart_exit_spot_trail||0)*100).toFixed(2)}% from its peak`,
      'Monitors live Binance spot price in parallel. If spot starts reversing from its high, exit the position immediately ‚Äî spot leads Kalshi contracts by ~15s so this is an early warning signal.')}

    ${isMomentum ? '<div class="rules-stopped" style="margin-top:.75rem">‚èπ Container stopped ‚Äî do not restart without new strategy</div>' : ''}
  </div>`;
}

// Helper: read current profit_target values from DOM inputs for a sport card
function getProfitTarget(sport) {
  const card = [...document.querySelectorAll('.rules-card')].find(c => c.innerHTML.includes(`'${sport}'`));
  if (!card) return {};
  const sel = card.querySelector('select');
  const inputs = [...card.querySelectorAll('input[type=number]')];
  const mode = sel ? sel.value : 'dynamic';
  if (mode === 'dynamic') return {mode, multiplier: parseFloat(inputs[3]?.value||0.5), min_profit: parseInt(inputs[4]?.value||2)};
  if (mode === 'fixed_by_half') return {mode, profit_1h: parseInt(inputs[3]?.value||15), profit_2h: parseInt(inputs[4]?.value||25), tie_profit: parseInt(inputs[5]?.value||15)};
  return {mode};
}

function getEdgeDecay(sport) {
  const card = [...document.querySelectorAll('.rules-card')].find(c => c.innerHTML.includes(`getEdgeDecay('${sport}')`));
  if (!card) return {};
  const inputs = [...card.querySelectorAll('input[type=number]')];
  return {enabled: true, tighten_hours: parseFloat(inputs.at(-2)?.value||2), tighten_factor: parseFloat(inputs.at(-1)?.value||0.7)};
}

async function saveSportField(sport, field, value) {
  const fb = document.getElementById('fb-' + sport);
  if (fb) { fb.textContent = 'Saving‚Ä¶'; fb.className = 'rules-feedback'; }
  try {
    const res = await fetch('/proxy/sports-arb/api/config', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Basic ' + btoa('admin:changeme123'),
      },
      body: JSON.stringify({[sport]: {[field]: value}}),
    });
    const data = await res.json();
    if (data.ok) {
      if (fb) { fb.textContent = '‚úì Saved'; fb.className = 'rules-feedback ok'; setTimeout(()=>{ if(fb) fb.textContent=''; }, 2000); }
    } else {
      if (fb) { fb.textContent = 'Error: ' + (data.error||'unknown'); fb.className = 'rules-feedback err'; }
    }
  } catch(e) {
    if (fb) { fb.textContent = 'Network error'; fb.className = 'rules-feedback err'; }
  }
}
</script>
</body>
</html>
